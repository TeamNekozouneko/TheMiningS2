#==================================================
#| #Ores.sk
#| 鉱石の実装・管理モジュール
#|
#| Nekozouneko Group Developer
#==================================================

Options:
    DO_NOT_REVIVE_AROUND_BLOCKS: 3
    CANNOT_BREAK_LESS_THAN_SUNLIGHT: 10

function onBreakOreHandle(p: player, centerBlock: block) :: boolean:
    #初期化
    add {_centerBlock} to {_processBlocks::*}
    set {_tool} to {_p}'s tool
    return false if isOreBreakable({_tool}, {_centerBlock}) is false

    set {_fortuneLevel} to getItemEnchantmentLevel({_tool}, "fortune")
    set {_autoCollectLevel} to getItemEnchantmentLevel({_tool}, "auto_collect")
    set {_autoSellLevel} to getItemEnchantmentLevel({_tool}, "auto_sell")
    set {_rangeMiningLevel} to getItemEnchantmentLevel({_tool}, "range_mining")

    set {_processBlocks::*} to enchantmentRangeMiningHandle({_p}, {_tool}, {_centerBlock}, {_rangeMiningLevel})
    loop {_processBlocks::*}:
        set {_type} to type of loop-value
        add getDefine("DROP_ITEMS::%{_type}%") to {_dropItems::*}
        add getDefine("EARN_EXP::%{_type}%") to {_earnExp}
    
    #エンチャント効果の後処理
    #[Fortune]
    set {_fortuneMultiplier} to enchantmentGetFortuneMultiplier({_fortuneLevel})
    if {_fortuneMultiplier} != 1:
        loop {_dropItems::*}:
            set item amount of loop-value to (item amount of loop-value) * {_fortuneMultiplier}
    #[AutoSell]
    set {_soldItems::*} to enchantmentAutoSellHandle({_p}, {_dropItems::*}, {_autoSellLevel})
    remove {_soldItems::*} from {_dropItems::*}
    #[AutoCollect]
    set {_remainDrops::*} to enchantmentAutoCollectHandle({_p}, {_dropItems::*}, {_autoCollectLevel})

    #ブロック破壊処理
    update {_processBlocks::*} as air without neighbouring updates

    #ドロップ処理
    if size of {_remainDrops::*} > 0:
        drop getMergedDropItems({_remainDrops::*}) at location of {_centerBlock} without velocity
    
    #EXPの付与
    profileExpIncrease({_p}, {_earnExp}, "ORES_BREAK")

    #統計データの反映
    profileStatisticsIncrease({_p}, "mineQuantity", size of {_processBlocks::*})

    #ガイド MINE_ORE_10
    guideTriggerIncreaseHandle({_p}, "MINE_ORE_10", size of {_processBlocks::*})

    return true

function isOreBreakable(tool: item, block: block) :: boolean:
    set {_toolId} to getItemId({_tool})
    return false if {_toolId} is not set

    set {_type} to type of {_block}
    if getDefineList("BREAKABLE_ORES::%{_toolId}%") doesn't contain {_type}:
        return false
    
    set {_falseFlag} to 0
    set {_breakableRegions::*} to getDefineList("BREAKABLE_REGIONS")
    set {_falseFlag} to size of ({_breakableRegions::*} where [isInWGRegion({_block}, input) is false])
    return false if size of {_breakableRegions::*} is {_falseFlag}

    return true

#鉱石復活の定期処理
function oreReviveAsyncHandler():
    run 0 ticks later repeating every getDefine("REVIVE_INTERVAL"):
        set {_players::*} to getAllPlayersInMine()
        #Revive Countdown
        playSound({_players::*} , "OreReviveStart")
        loop 30 times: #15秒分（30 * 10 tick）
            send action bar getDefine("LANG::ORES_REVIVE_1") to {_players::*}  if mod(loop-number, 2) != 0
            send action bar getDefine("LANG::ORES_REVIVE_2") to {_players::*}  if mod(loop-number, 2) = 0
            wait 10 tick

        #Revive Processing
        set {_breakableRegions::*} to getDefineList("BREAKABLE_REGIONS")
        loop {_breakableRegions::*}:
            set {_regionPlayers::*} to getAllPlayersInWGRegion(loop-value)
            set {_destination} to getDefine("REVIVE_ORE_DESTINATION::%loop-value%")
            teleport {_regionPlayers::*} to getDefine("LOCATION::%{_destination}%")
        
        loop getDefineList("REVIVE_ORE_SCHEMATICS"):
            paste schematic loop-value at location(0, 0, 0, world "world", 0, 0)
        
        #Revive Processed
        playSound({_players::*} , "OreRevived")
        send action bar getDefine("LANG::ORES_REVIVED") to {_players::*}

local function getAroundAverageSunLight(location: location) :: number:
    loop all blocks in radius 1 around {_location}:
        add (sunlight level at loop-block) to {_sunlight::*} if loop-block is air
    return sum({_sunlight::*})/(size of {_sunlight::*})

local function getMergedDropItems(dropItems: objects) :: objects:
    loop {_dropItems::*}:
        loop (item amount of loop-value) times:
            add 1 of loop-value-1 to {_flatted::*}
    while size of {_flatted::*} > 0:
        set {_first} to first element of {_flatted::*}
        set {_amount} to size of {_flatted::*} where [input is {_first}]
        add {_amount} of {_first} to {_results::*}
        remove all {_first} from {_flatted::*}
    return {_results::*}

local function isInWGRegion(b: block, region: string) :: boolean:
    return true if region at {_b} contains {_region}
    return false

local function getAllPlayersInWGRegion(region: string) :: objects:
    return all players where [region at input contains {_region}]