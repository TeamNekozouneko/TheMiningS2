#==================================================
#| #Quest.sk
#| ã‚¯ã‚¨ã‚¹ãƒˆã®å®Ÿè£…ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
#|
#| Nekozouneko Group Developer
#==================================================

#enum guiType {
# QUEST_MAIN,
#}

#enum questType {
# 1, (Daily)
# 2, (Weekly)
#}

Options:
    QUEST_RESET_CHECK_INTERVAL: 10 second #0:00ã‚’å›ã£ãŸã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–“éš”

    MAIN_TITLE_NAME: "&6&lã‚¯ã‚¨ã‚¹ãƒˆ &8ãƒã‚¤ã‚¯ã‚¨ã‚¹ãƒˆã‚’è¦‹ã‚‹"
    MAIN_BACKGROUND_ICON: gray stained glass pane named "&r"

    MAIN_INFO_ICON: book named "&aã‚¯ã‚¨ã‚¹ãƒˆã¨ã¯ï¼Ÿ" with lore "&7ã“ã“ã§ã‚¯ã‚¨ã‚¹ãƒˆã‚’å—æ³¨ã—ã¦é”æˆã™ã‚‹ã¨ã€", "&7ã‚¯ã‚¨ã‚¹ãƒˆã«å¿œã˜ã¦å ±é…¬ã‚’ã‚‚ã‚‰ã†ã“ã¨ãŒã§ãã¾ã™ã€‚", "&fç¾åœ¨ã¯ã€ãƒ‡ã‚¤ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆã®ã¿" and "&få—æ³¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"
    MAIN_DAILY_INFO_ICON: trial key named "&6ãƒ‡ã‚¤ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ" with lore "&7æ¯æ—¥0:00ï¼ˆæ—¥æœ¬æ¨™æº–æ™‚ï¼‰ã«" and "&7æ›´æ–°ã•ã‚Œã‚‹ã‚¯ã‚¨ã‚¹ãƒˆã§ã™ã€‚ï¼ˆæœ€å¤§10å€‹ï¼‰"
    MAIN_WEEKLY_INFO_ICON: ominous trial key named "&6ã‚¦ã‚£ãƒ¼ã‚¯ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ" with lore "&7æ¯é€±æœˆæ›œæ—¥0:00ï¼ˆæ—¥æœ¬æ¨™æº–æ™‚ï¼‰ã«" and "&7æ›´æ–°ã•ã‚Œã‚‹ã‚¯ã‚¨ã‚¹ãƒˆã§ã™ã€‚ï¼ˆæœ€å¤§5å€‹ï¼‰"

function questPeriodicCheckHandlerInit():
    set {_checkInterval} to getDefine("QUEST_CHECK_INTERVAL")
    async run 0 ticks later repeating every {_checkInterval}:
        #Periodic Handler
        questCompleteCheckHandler_SavingMoney()

function questGuiHandle(p: player):
    openGui({_p}, "QUEST_MAIN")

local function openGui(p: player, guiType: string):
    #QUEST_MAIN
    if {_guiType} is "QUEST_MAIN":
        playSound(getObjects({_p}), "Talk")
        open chest inventory with 6 row named {@MAIN_TITLE_NAME} to {_p}
        
        #Draw Frames
        loop 6 * 9 times:
            set slot (loop-number - 1) of {_p}'s current inventory to {@MAIN_BACKGROUND_ICON}
        
        #Draw Icons
        set slot 4 of {_p}'s current inventory to {@MAIN_INFO_ICON}

        set slot 10 of {_p}'s current inventory to {@MAIN_DAILY_INFO_ICON}
        set slot 16 of {_p}'s current inventory to {@MAIN_DAILY_INFO_ICON}

        set slot 37 of {_p}'s current inventory to {@MAIN_WEEKLY_INFO_ICON}
        set slot 43 of {_p}'s current inventory to {@MAIN_WEEKLY_INFO_ICON}

        #Rendering Quests
        renderQuests({_p})

function onInventoryClickQuestHandle(p: player, item: itemtype) :: boolean:
    set {_invName} to name of {_p}'s current inventory

    #QUEST_MAIN
    if {_invName} is {@MAIN_TITLE_NAME}:
        set {_questId} to getQuestIdFromItem({_item})
        return true if {_questId} is not set
        questClickHandle({_p}, {_questId})
        return true

    return false

local function questClickHandle(p: player, questId: string):
    set {_status} to getQuestStatusFromId({_p}, {_questId})
    exit if {_status} is not set
    if {_status} is "has":
        questOrder({_p}, {_questId})
    if {_status} is "complete":
        questRewards({_p}, {_questId})
    renderQuests({_p})


function questAssignHandler():
    run 0 ticks later repeating every second:
        set {_quests::*} to getDefineList("QUESTS")
        #ãƒ­ã‚°ã‚¤ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ‡ã‚¤ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆè‡ªå‹•å‰²ã‚Šå½“ã¦
        set {_dailyAssignMax} to getDefine("QUEST_DAILY_ASSIGN_MAX")
        set {_dailyQuests::*} to {_quests::*} where [isQuestDaily(input) is true]
        loop all players:
            while getAssignedAmount(loop-player, 1) < {_dailyAssignMax}:
                #å‰²ã‚Šå½“ã¦å‡¦ç†
                set {_random} to random element out of ({_dailyQuests::*} where [isQuestAssigned(loop-player, input) is false])
                exit 1 loop if {_random} is not set

                add {_random} to {quest.has::%loop-player's uuid%::*}
                logInfo("QUEST_ASSIGNED", getQuestLogParameters(loop-player's uuid, {_random}))

function questResetAssignHandler():
    run 0 ticks later repeating every {@QUEST_RESET_CHECK_INTERVAL}:
        set {_now} to now
        set {_day} to ({_now} formatted as "dd") parsed as integer

        if {quest.lastFlaggedDay} and {_day} is set:
            if {quest.lastFlaggedDay} is not {_day}:
                #ãƒªã‚»ãƒƒãƒˆ
                add {_now} formatted human-readable to {_res::*}
                add {quest.lastFlaggedDay} to {_res::*}
                add {_day} to {_res::*}
                logInfo("QUEST_RESETTED", {_res::*})

                loop all offline players:
                    clear {quest.has::%loop-value's uuid%::*}
                    clear {quest.ordering::%loop-value's uuid%::*}
                    clear {quest.complete::%loop-value's uuid%::*}
                    clear {quest.rewarded::%loop-value's uuid%::*}
                    loop getDefineList("QUESTS"):
                        questTriggerStatisticsCompleteInit(loop-value-1, loop-value-2)
                        clear {quest.triggers::%loop-value-1's uuid%::%loop-value-2%}
                
        set {quest.lastFlaggedDay} to {_day}

local function renderQuests(p: player):
    set {_invName} to name of {_p}'s current inventory
    exit if {_invName} is not {@MAIN_TITLE_NAME}

    #Calculate Daily Slots
    set {_baseSlot} to 11
    loop 5 times:
        add {_baseSlot} + (loop-number - 1) to {_dailySlots::*}
    set {_baseSlot} to 20
    loop 5 times:
        add {_baseSlot} + (loop-number - 1) to {_dailySlots::*}
    #Calculate Weekly Slots
    set {_baseSlot} to 38
    loop 5 times:
        add {_baseSlot} + (loop-number - 1) to {_weeklySlots::*}
    
    #Replace Slots to Air
    loop {_dailySlots::*}:
        set slot loop-value of {_p}'s current inventory to air
    loop {_weeklySlots::*}:
        set slot loop-value of {_p}'s current inventory to air
    
    #Render Quests
    set {_currentDailySlotIndex} to 1
    #æœªå—æ³¨ï¼ˆHasï¼‰
    loop {quest.has::%{_p}'s uuid%::*}:
        set {_item} to getBaseQuestDisplayItem(loop-value, getBannerPatternItemsFromModulo({_currentDailySlotIndex}))
        #Lores
        add "&r" to lore of {_item}
        add "&câ„¹ å—æ³¨ã—ã¦ã„ã¾ã›ã‚“" to lore of {_item}
        add "&eÂ» ã‚¯ãƒªãƒƒã‚¯ã—ã¦å—æ³¨ã™ã‚‹ Â«" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to {_item}
        add 1 to {_currentDailySlotIndex}
    #é€²è¡Œä¸­ï¼ˆOrderingï¼‰
    loop {quest.ordering::%{_p}'s uuid%::*}:
        set {_completeTrigger} to getDefine("QUEST_COMPLETE_TRIGGER::%loop-value%")
        set {_currentTrigger} to getTrigger({_p}, loop-value)
        set {_item} to getBaseQuestDisplayItem(loop-value, getBannerPatternItemsFromModulo({_currentDailySlotIndex}))
        #Lores
        add "&r" to lore of {_item}
        add "&7(&3%{_currentTrigger}%&7/%{_completeTrigger}%&7)" to lore of {_item}
        add "&eâ„¹ ã‚¯ã‚¨ã‚¹ãƒˆãŒé€²è¡Œä¸­ã§ã™" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to Glowing({_item})
        add 1 to {_currentDailySlotIndex}
    #å®Œäº†æ¸ˆã¿ï¼ˆCompleteï¼‰
    loop {quest.complete::%{_p}'s uuid%::*}:
        set {_item} to getBaseQuestDisplayItem(loop-value, experience bottle)
        #Lores
        add "&r" to lore of {_item}
        add "&aâ„¹ ã‚¯ã‚¨ã‚¹ãƒˆãŒé”æˆæ¸ˆã¿ã§ã™" to lore of {_item}
        add "&eÂ» ã‚¯ãƒªãƒƒã‚¯ã—ã¦å ±é…¬ã‚’å—ã‘å–ã‚‹ Â«" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to {_item}
        add 1 to {_currentDailySlotIndex}
    #å ±é…¬å—ã‘å–ã‚Šæ¸ˆã¿ï¼ˆRewardedï¼‰
    loop {quest.rewarded::%{_p}'s uuid%::*}:
        set {_item} to getBaseQuestDisplayItem(loop-value, gunpowder)
        #Lores
        add "&r" to lore of {_item}
        add "&câ„¹ å ±é…¬ã‚’å—ã‘å–ã‚Šæ¸ˆã¿ã§ã™" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to {_item}
        add 1 to {_currentDailySlotIndex}

local function getBaseQuestDisplayItem(questId: string, baseItem: item) :: item:
    set {_questTitle} to getDefine("QUEST_TITLE::%{_questId}%")
    set {_itemName} to "&b%{_questTitle}%"
    set {_lores::*} to "&3Â» å ±é…¬" and getRewardLores({_questId})
    set {_item} to {_baseItem} named {_itemName} with lore {_lores::*}
    set string tag "TheMining;quest;id" of custom nbt of {_item} to {_questId}
    return {_item}

local function getRewardLores(questId: string) :: objects:
    set {_exp} to getDefine("QUEST_REWARD::%{_questId}%::EXP")
    set {_money} to getDefine("QUEST_REWARD::%{_questId}%::MONEY")
    add "&b ğŸ”¨ &3%formatNumber({_exp})% EXP" to {_results::*} if {_exp} is set
    add "&e ğŸ’° &6%formatNumber({_money})%G" to {_results::*} if {_money} is set
    return {_results::*}

#æ•°å­—ã‹ã‚‰ãƒãƒŠãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¨®é¡ã‚’ä¸€æ„ã«æ±ºå®šã™ã‚‹é–¢æ•°
#ï¼ˆã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹ãŒæ›´æ–°ã•ã‚Œãªã„é™ã‚Šã¯ã€åŒã˜ãƒãƒŠãƒ¼æ¨¡æ§˜ã‚’ä½¿ç”¨ã—ãŸã„ãŸã‚ï¼‰
local function getBannerPatternItemsFromModulo(digest: integer) :: item:
    set {_patterns::*} to getAllBannerPatternItems()
    set {_hash} to mod({_digest}, size of {_patterns::*})

    #ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—ã®çµæœã®ç¯„å›²ã¯ 0 <= mod(digest, patternSize) < patternSize
    #ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã¯1 < index <= patternSize ã§ã‚ã‚‹ãŸã‚+1ã‚’ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ä½¿ç”¨ã™ã‚‹
    set {_index} to {_hash} + 1

    return {_patterns::%{_index}%}

#enum type {
# QUEST_ORDERED,
# QUEST_COMPLETE,
# QUEST_REWARDS
#}
local function sendNotify(p: player, type: string, questId: string):
    set {_base::*} to getDefineList("LANG::QUEST_BASE")
    #ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ™ãƒ¼ã‚¹
    #1ç•ªç›®ï¼šãƒ‡ã‚¤ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ or ã‚¦ã‚£ãƒ¼ã‚¯ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ
    #2ç•ªç›®ï¼šã‚¯ã‚¨ã‚¹ãƒˆçŠ¶æ³
    #3ç•ªç›®ï¼šã‚¯ã‚¨ã‚¹ãƒˆå
    #4ç•ªç›®ï¼šå ±é…¬å†…å®¹ï¼ˆgetRewardLoresé–¢æ•°ã‚’ä½¿ç”¨ï¼‰
    set {_message} to concat {_base::*} with nl

    #ã‚¯ã‚¨ã‚¹ãƒˆçŠ¶æ³å®šç¾©
    set {_status::QUEST_ORDERED} to "&a&lå—æ³¨"
    set {_status::QUEST_COMPLETE} to "&b&lå®Œäº†"
    set {_status::QUEST_REWARDS} to "&d&lå ±é…¬"

    set {_rewards::*} to getRewardLores({_questId})
    set {_rewardLoreText} to concat {_rewards::*} with nl
    set {_questType} to getDefine("LANG::QUEST_DAILY") if isQuestDaily({_questId}) is true
    set {_questType} to getDefine("LANG::QUEST_WEEKLY") if isQuestWeekly({_questId}) is true

    exit if {_status::%{_type}%} is not set
    exit if size of {_rewards::*} <= 0

    set {_message} to substitution({_message}, {_questType})
    set {_message} to substitution({_message}, {_status::%{_type}%})
    set {_message} to substitution({_message}, getDefine("QUEST_TITLE::%{_questId}%"))
    set {_message} to substitution({_message}, {_rewardLoreText})

    send {_message} to {_p}


local function getAssignedAmount(p: player, questType: integer) :: integer:
    set {_result} to 0
    if {_questType} is 1:
        add size of ({quest.has::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
        add size of ({quest.ordering::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
        add size of ({quest.complete::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
        add size of ({quest.rewarded::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
    else if {_questType} is 2:
        add size of ({quest.has::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
        add size of ({quest.ordering::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
        add size of ({quest.complete::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
        add size of ({quest.rewarded::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
    return {_result}

local function getTrigger(p: player, questId: string) :: integer:
    set {_trigger} to {quest.triggers::%{_p}'s uuid%::%{_questId}%}
    return 0 if {_trigger} is not set
    return {_trigger}

function questTriggerIncreaseHandle(p: player, questId: string, increaseValue: integer = 1):
    exit if isQuestCompletable({_p}, {_questId}) is false
    
    set {_after} to getTrigger({_p}, {_questId}) + {_increaseValue}
    set {_maxTrigger} to getDefine("QUEST_COMPLETE_TRIGGER::%{_questId}%")
    if {_after} >= {_maxTrigger}:
        #å®Œäº†å‡¦ç†
        set {quest.triggers::%{_p}'s uuid%::%{_questId}%} to {_maxTrigger}
        questComplete({_p}, {_questId}, true)
        questTriggerStatisticsCompleteInit({_p}, {_questId})
    else:
        #å¢—åŠ å‡¦ç†
        add {_increaseValue} to {quest.triggers::%{_p}'s uuid%::%{_questId}%}

local function questTriggerStatisticsOrderInit(p: player, questId: string):
    profileStatisticsSet({_p}, "_questTrigger_savingMoney500_currentMoney", profileMoneyGet({_p})) if {_questId} is "SAVING_MONEY_500"
    profileStatisticsSet({_p}, "_questTrigger_savingMoney1000_currentMoney", profileMoneyGet({_p})) if {_questId} is "SAVING_MONEY_1000"
    profileStatisticsSet({_p}, "_questTrigger_savingMoney5000_currentMoney", profileMoneyGet({_p})) if {_questId} is "SAVING_MONEY_5000"

local function questTriggerStatisticsCompleteInit(p: offline player, questId: string):
    profileStatisticsClear({_p}, "_questTrigger_savingMoney500_currentMoney") if {_questId} is "SAVING_MONEY_500"
    profileStatisticsClear({_p}, "_questTrigger_savingMoney1000_currentMoney") if {_questId} is "SAVING_MONEY_1000"
    profileStatisticsClear({_p}, "_questTrigger_savingMoney5000_currentMoney") if {_questId} is "SAVING_MONEY_5000"

local function getQuestIdFromItem(item: item) :: string:
    return string tag "TheMining;quest;id" of custom nbt of {_item}

local function isQuestDaily(questId: string) :: boolean:
    return true if getDefine("QUEST_TYPE::%{_questId}%") is 1
    return false

local function isQuestWeekly(questId: string) :: boolean:
    return true if getDefine("QUEST_TYPE::%{_questId}%") is 2
    return false

local function getQuestStatusFromId(p: player, questId: string) :: string:
    return "has" if {quest.has::%{_p}'s uuid%::*} contains {_questId}
    return "ordering" if {quest.ordering::%{_p}'s uuid%::*} contains {_questId}
    return "complete" if {quest.complete::%{_p}'s uuid%::*} contains {_questId}
    return "rewarded" if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}

local function isQuestOrderable(p: player, questId: string) :: boolean:
    return false if {quest.has::%{_p}'s uuid%::*} doesn't contain {_questId}
    return false if {quest.ordering::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.complete::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}
    return true

local function isQuestCompletable(p: player, questId: string) :: boolean:
    return false if {quest.has::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.ordering::%{_p}'s uuid%::*} doesn't contain {_questId}
    return false if {quest.complete::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}
    return true

local function isQuestRewardable(p: player, questId: string) :: boolean:
    return false if {quest.has::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.ordering::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.complete::%{_p}'s uuid%::*} doesn't contain {_questId}
    return false if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}
    return true

function isQuestInProgress(p: player, questId: string) :: boolean:
    return false if {quest.ordering::%{_p}'s uuid%::*} doesn't contain {_questId}
    return true

function isQuestAssigned(p: player, questId: string) :: boolean:
    return true if {quest.has::%{_p}'s uuid%::*} contains {_questId}
    return true if {quest.ordering::%{_p}'s uuid%::*} contains {_questId}
    return true if {quest.complete::%{_p}'s uuid%::*} contains {_questId}
    return true if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}
    return false

local function questOrder(p: player, questId: string) :: boolean:
    if isQuestOrderable({_p}, {_questId}) is true:
        #æ®‹ã£ã¦ã„ã‚‹ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆquestCompleteæ™‚ã«å‰Šé™¤ã™ã‚‹ãŒå¿µã®ãŸã‚ï¼‰
        clear {quest.triggers::%{_p}'s uuid%::%{_questId}%}

        #ã‚¯ã‚¨ã‚¹ãƒˆã®å¤‰æ•°ãƒ‡ãƒ¼ã‚¿é©ç”¨
        remove {_questId} from {quest.has::%{_p}'s uuid%::*}
        add {_questId} to {quest.ordering::%{_p}'s uuid%::*}

        #UI
        playSound({_p}, "QuestOrdered")
        sendNotify({_p}, "QUEST_ORDERED", {_questId})

        #ãƒ‡ãƒ¼ã‚¿æ“ä½œ
        logInfo("QUEST_ORDERED", getQuestLogParameters({_p}'s uuid, {_questId}))
        questTriggerStatisticsOrderInit({_p}, {_questId})

        #ã‚¬ã‚¤ãƒ‰ ORDER_QUEST
        guideTriggerIncreaseHandle({_p}, "ORDER_QUEST")

        return true

    logError("ERR_QUEST_ORDER", getQuestLogParameters({_p}'s uuid, {_questId}))
    return false

local function questComplete(p: player, questId: string, isSkipCondition: boolean = false) :: boolean:
    set {_flag} to false
    set {_flag} to true if {_isSkipCondition} is true
    set {_flag} to true if isQuestCompletable({_p}, {_questId}) is true

    if {_flag} is true:
        #ãƒˆãƒªã‚¬ãƒ¼ã®å‰Šé™¤
        clear {quest.triggers::%{_p}'s uuid%::%{_questId}%}

        #ã‚¯ã‚¨ã‚¹ãƒˆã®å¤‰æ•°ãƒ‡ãƒ¼ã‚¿é©ç”¨
        remove {_questId} from {quest.ordering::%{_p}'s uuid%::*}
        add {_questId} to {quest.complete::%{_p}'s uuid%::*}

        #UI
        playSound({_p}, "QuestComplete")
        sendNotify({_p}, "QUEST_COMPLETE", {_questId})

        logInfo("QUEST_COMPLETE", getQuestLogParameters({_p}'s uuid, {_questId}))

        #ã‚¬ã‚¤ãƒ‰ COMPLETE_QUEST
        guideTriggerIncreaseHandle({_p}, "COMPLETE_QUEST")

        return true
        
    logError("ERR_QUEST_COMPLETE", getQuestLogParameters({_p}'s uuid, {_questId}))
    return false

local function questRewards(p: player, questId: string) :: boolean:
    if isQuestRewardable({_p}, {_questId}) is true:
        remove {_questId} from {quest.complete::%{_p}'s uuid%::*}
        add {_questId} to {quest.rewarded::%{_p}'s uuid%::*}
        
        #å ±é…¬ã®ä»˜ä¸
        set {_exp} to getDefine("QUEST_REWARD::%{_questId}%::EXP")
        set {_money} to getDefine("QUEST_REWARD::%{_questId}%::MONEY")
        profileExpIncrease({_p}, {_exp}, "QUEST_REWARDS") if {_exp} is set
        profileMoneyIncrease({_p}, {_money}, "QUEST_REWARDS") if {_money} is set

        #UI
        playSound({_p}, "QuestRewards")
        sendNotify({_p}, "QUEST_REWARDS", {_questId})

        logInfo("QUEST_RECEIVE_REWARDS", getQuestLogParameters({_p}'s uuid, {_questId}))
        
        #ã‚¬ã‚¤ãƒ‰ REWARD_QUEST
        guideTriggerIncreaseHandle({_p}, "REWARD_QUEST")
        
        return true

    logError("ERR_QUEST_RECEIVE_REWARDS", getQuestLogParameters({_p}'s uuid, {_questId}))
    return false

#Interface
local function getQuestLogParameters(uuid: string, questId: string) :: objects:
    add {_uuid} to {_res::*}
    add {_questId} to {_res::*}
    return {_res::*}