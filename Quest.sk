#==================================================
#| #Quest.sk
#| ã‚¯ã‚¨ã‚¹ãƒˆã®å®Ÿè£…ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
#|
#| Nekozouneko Group Developer
#==================================================

#enum guiType {
# QUEST_MAIN,
#}

#enum questType {
# 1, (Daily)
# 2, (Weekly)
#}

Options:
    MAIN_TITLE_NAME: "&6&lã‚¯ã‚¨ã‚¹ãƒˆ &8ãƒã‚¤ã‚¯ã‚¨ã‚¹ãƒˆã‚’è¦‹ã‚‹"
    MAIN_BACKGROUND_ICON: gray stained glass pane named "&r"

    MAIN_INFO_ICON: book named "&aã‚¯ã‚¨ã‚¹ãƒˆã¨ã¯ï¼Ÿ" with lore "&7ã“ã“ã§ã‚¯ã‚¨ã‚¹ãƒˆã‚’å—æ³¨ã—ã¦é”æˆã™ã‚‹ã¨ã€", "&7ã‚¯ã‚¨ã‚¹ãƒˆã«å¿œã˜ã¦å ±é…¬ã‚’ã‚‚ã‚‰ã†ã“ã¨ãŒã§ãã¾ã™ã€‚", "&fç¾åœ¨ã¯ã€ãƒ‡ã‚¤ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆã®ã¿" and "&få—æ³¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚"
    MAIN_DAILY_INFO_ICON: trial key named "&6ãƒ‡ã‚¤ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ" with lore "&7æ¯æ—¥0:00ï¼ˆæ—¥æœ¬æ¨™æº–æ™‚ï¼‰ã«" and "&7æ›´æ–°ã•ã‚Œã‚‹ã‚¯ã‚¨ã‚¹ãƒˆã§ã™ã€‚ï¼ˆæœ€å¤§10å€‹ï¼‰"
    MAIN_WEEKLY_INFO_ICON: ominous trial key named "&6ã‚¦ã‚£ãƒ¼ã‚¯ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆ" with lore "&7æ¯é€±æœˆæ›œæ—¥0:00ï¼ˆæ—¥æœ¬æ¨™æº–æ™‚ï¼‰ã«" and "&7æ›´æ–°ã•ã‚Œã‚‹ã‚¯ã‚¨ã‚¹ãƒˆã§ã™ã€‚ï¼ˆæœ€å¤§5å€‹ï¼‰"

function questPeriodicCheckHandlerInit():
    set {_checkInterval} to getDefine("QUEST_CHECK_INTERVAL")
    async run 0 ticks later repeating every {_checkInterval}:
        #Periodic Handler
        questCompleteCheckHandler_SavingMoney()

function questGuiHandle(p: player):
    openGui({_p}, "QUEST_MAIN")

local function openGui(p: player, guiType: string):
    #QUEST_MAIN
    if {_guiType} is "QUEST_MAIN":
        open chest inventory with 6 row named {@MAIN_TITLE_NAME} to {_p}
        
        #Draw Frames
        loop 6 * 9 times:
            set slot (loop-number - 1) of {_p}'s current inventory to {@MAIN_BACKGROUND_ICON}
        
        #Draw Icons
        set slot 4 of {_p}'s current inventory to {@MAIN_INFO_ICON}

        set slot 10 of {_p}'s current inventory to {@MAIN_DAILY_INFO_ICON}
        set slot 16 of {_p}'s current inventory to {@MAIN_DAILY_INFO_ICON}

        set slot 37 of {_p}'s current inventory to {@MAIN_WEEKLY_INFO_ICON}
        set slot 43 of {_p}'s current inventory to {@MAIN_WEEKLY_INFO_ICON}

        #Rendering Quests
        renderQuests({_p})

function onInventoryClickQuestHandle(p: player, item: itemtype) :: boolean:
    set {_invName} to name of {_p}'s current inventory

    #QUEST_MAIN
    if {_invName} is {@MAIN_TITLE_NAME}:
        set {_questId} to getQuestIdFromItem({_item})
        return true if {_questId} is not set
        questClickHandle({_p}, {_questId})
        return true

    return false

local function questClickHandle(p: player, questId: string):
    set {_status} to getQuestStatusFromId({_p}, {_questId})
    exit if {_status} is not set
    if {_status} is "has":
        questOrder({_p}, {_questId})
    if {_status} is "complete":
        questRewards({_p}, {_questId})
    renderQuests({_p})


function questAssignHandler():
    run 0 ticks later repeating every second:
        #ãƒ­ã‚°ã‚¤ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ‡ã‚¤ãƒªãƒ¼ã‚¯ã‚¨ã‚¹ãƒˆè‡ªå‹•å‰²ã‚Šå½“ã¦
        set {_dailyAssignMax} to getDefine("QUEST_DAILY_ASSIGN_MAX")
        set {_quests::*} to getDefineList("QUESTS") where [isQuestDaily(input) is true]
        loop all players:
            set {_assignedAmount} to getAssignedAmount(loop-player, 1)
            while {_assignedAmount} < {_dailyAssignMax}:
                exit loop if size of {_quests::*} <= {_assignedAmount}
                exit loop if questAssign(loop-player, 1) is false
        #å­˜åœ¨ã—ãªã„ã‚¯ã‚¨ã‚¹ãƒˆã®è‡ªå‹•ä¿®æ­£
        loop all players:
            remove {quest.has::%loop-player's uuid%::*} where [{_quests::*} doesn't contain input] from {quest.has::%loop-player's uuid%::*}
            remove {quest.ordering::%loop-player's uuid%::*} where [{_quests::*} doesn't contain input] from {quest.ordering::%loop-player's uuid%::*}
            remove {quest.complete::%loop-player's uuid%::*} where [{_quests::*} doesn't contain input] from {quest.complete::%loop-player's uuid%::*}
            remove {quest.rewarded::%loop-player's uuid%::*} where [{_quests::*} doesn't contain input] from {quest.rewarded::%loop-player's uuid%::*}

local function questAssign(p: player, questType: integer) :: boolean:
    if {_questType} is 1:
        set {_quests::*} to getDefineList("QUESTS") where [isQuestDaily(input) is true]
        set {_random} to random element out of ({_quests::*} where [{quest.has::%{_p}'s uuid%::*} doesn't contain input])
        return false if {_random} is not set
        add {_random} to {quest.has::%{_p}'s uuid%::*}
        logInfo("QUEST_ASSIGNED", getQuestLogParameters({_p}'s uuid, {_random}))
        return true
    return false

local function renderQuests(p: player):
    set {_invName} to name of {_p}'s current inventory
    exit if {_invName} is not {@MAIN_TITLE_NAME}

    #Calculate Daily Slots
    set {_baseSlot} to 11
    loop 5 times:
        add {_baseSlot} + (loop-number - 1) to {_dailySlots::*}
    set {_baseSlot} to 20
    loop 5 times:
        add {_baseSlot} + (loop-number - 1) to {_dailySlots::*}
    #Calculate Weekly Slots
    set {_baseSlot} to 38
    loop 5 times:
        add {_baseSlot} + (loop-number - 1) to {_weeklySlots::*}
    
    #Replace Slots to Air
    loop {_dailySlots::*}:
        set slot loop-value of {_p}'s current inventory to air
    loop {_weeklySlots::*}:
        set slot loop-value of {_p}'s current inventory to air
    
    #Render Quests
    set {_currentDailySlotIndex} to 1
    #æœªå—æ³¨ï¼ˆHasï¼‰
    loop {quest.has::%{_p}'s uuid%::*}:
        set {_item} to getBaseQuestDisplayItem(loop-value, getBannerPatternItemsFromModulo({_currentDailySlotIndex}))
        #Lores
        add "&r" to lore of {_item}
        add "&câ„¹ å—æ³¨ã—ã¦ã„ã¾ã›ã‚“" to lore of {_item}
        add "&eÂ» ã‚¯ãƒªãƒƒã‚¯ã—ã¦å—æ³¨ã™ã‚‹ Â«" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to {_item}
        add 1 to {_currentDailySlotIndex}
    #é€²è¡Œä¸­ï¼ˆOrderingï¼‰
    loop {quest.ordering::%{_p}'s uuid%::*}:
        set {_completeTrigger} to getDefine("QUEST_COMPLETE_TRIGGER::%loop-value%")
        set {_currentTrigger} to getTrigger({_p}, loop-value)
        set {_item} to getBaseQuestDisplayItem(loop-value, getBannerPatternItemsFromModulo({_currentDailySlotIndex}))
        #Lores
        add "&r" to lore of {_item}
        add "&7(&3%{_currentTrigger}%&7/%{_completeTrigger}%&7)" to lore of {_item}
        add "&eâ„¹ ã‚¯ã‚¨ã‚¹ãƒˆãŒé€²è¡Œä¸­ã§ã™" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to Glowing({_item})
        add 1 to {_currentDailySlotIndex}
    #å®Œäº†æ¸ˆã¿ï¼ˆCompleteï¼‰
    loop {quest.complete::%{_p}'s uuid%::*}:
        set {_item} to getBaseQuestDisplayItem(loop-value, experience bottle)
        #Lores
        add "&r" to lore of {_item}
        add "&aâ„¹ ã‚¯ã‚¨ã‚¹ãƒˆãŒé”æˆæ¸ˆã¿ã§ã™" to lore of {_item}
        add "&eÂ» ã‚¯ãƒªãƒƒã‚¯ã—ã¦å ±é…¬ã‚’å—ã‘å–ã‚‹ Â«" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to {_item}
        add 1 to {_currentDailySlotIndex}
    #å ±é…¬å—ã‘å–ã‚Šæ¸ˆã¿ï¼ˆRewardedï¼‰
    loop {quest.rewarded::%{_p}'s uuid%::*}:
        set {_item} to getBaseQuestDisplayItem(loop-value, gunpowder)
        #Lores
        add "&r" to lore of {_item}
        add "&câ„¹ å ±é…¬ã‚’å—ã‘å–ã‚Šæ¸ˆã¿ã§ã™" to lore of {_item}

        set slot {_dailySlots::%{_currentDailySlotIndex}%} of {_p}'s current inventory to {_item}
        add 1 to {_currentDailySlotIndex}

local function getBaseQuestDisplayItem(questId: string, baseItem: item) :: item:
    set {_questTitle} to getDefine("QUEST_TITLE::%{_questId}%")
    set {_itemName} to "&b%{_questTitle}%"
    set {_lores::*} to "&3Â» å ±é…¬" and getRewardLores({_questId})
    set {_item} to {_baseItem} named {_itemName} with lore {_lores::*}
    set string tag "TheMining;quest;id" of custom nbt of {_item} to {_questId}
    return {_item}

local function getRewardLores(questId: string) :: objects:
    set {_exp} to getDefine("QUEST_REWARD::%{_questId}%::EXP")
    set {_money} to getDefine("QUEST_REWARD::%{_questId}%::MONEY")
    add "&b ğŸ”¨ &3%formatNumber({_exp})% EXP" to {_results::*} if {_exp} is set
    add "&e ğŸ’° &6%formatNumber({_money})% å††" to {_results::*} if {_money} is set
    return {_results::*}

#æ•°å­—ã‹ã‚‰ãƒãƒŠãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¨®é¡ã‚’ä¸€æ„ã«æ±ºå®šã™ã‚‹é–¢æ•°
#ï¼ˆã‚¯ã‚¨ã‚¹ãƒˆå†…å®¹ãŒæ›´æ–°ã•ã‚Œãªã„é™ã‚Šã¯ã€åŒã˜ãƒãƒŠãƒ¼æ¨¡æ§˜ã‚’ä½¿ç”¨ã—ãŸã„ãŸã‚ï¼‰
local function getBannerPatternItemsFromModulo(digest: integer) :: item:
    set {_patterns::*} to getAllBannerPatternItems()
    set {_hash} to mod({_digest}, size of {_patterns::*})

    #ãƒ¢ã‚¸ãƒ¥ãƒ­æ¼”ç®—ã®çµæœã®ç¯„å›²ã¯ 0 <= mod(digest, patternSize) < patternSize
    #ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã¯1 < index <= patternSize ã§ã‚ã‚‹ãŸã‚+1ã‚’ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ä½¿ç”¨ã™ã‚‹
    set {_index} to {_hash} + 1

    return {_patterns::%{_index}%}

local function getAssignedAmount(p: player, questType: integer) :: integer:
    set {_result} to 0
    if {_questType} is 1:
        add size of ({quest.has::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
        add size of ({quest.ordering::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
        add size of ({quest.complete::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
        add size of ({quest.rewarded::%{_p}'s uuid%::*} where [isQuestDaily(input) is true]) to {_result}
    else if {_questType} is 2:
        add size of ({quest.has::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
        add size of ({quest.ordering::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
        add size of ({quest.complete::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
        add size of ({quest.rewarded::%{_p}'s uuid%::*} where [isQuestWeekly(input) is true]) to {_result}
    return {_result}

local function getTrigger(p: player, questId: string) :: integer:
    set {_trigger} to {quest.triggers::%{_p}'s uuid%::%{_questId}%}
    return 0 if {_trigger} is not set
    return {_trigger}

function questTriggerIncreaseHandle(p: player, questId: string, increaseValue: integer = 1):
    exit if isQuestCompletable({_p}, {_questId}) is false
    
    set {_after} to getTrigger({_p}, {_questId}) + {_increaseValue}
    set {_maxTrigger} to getDefine("QUEST_COMPLETE_TRIGGER::%{_questId}%")
    if {_after} >= {_maxTrigger}:
        #å®Œäº†å‡¦ç†
        set {quest.triggers::%{_p}'s uuid%::%{_questId}%} to {_maxTrigger}
        questComplete({_p}, {_questId}, true)
        questTriggerStatisticsCompleteInit({_p}, {_questId})
    else:
        #å¢—åŠ å‡¦ç†
        add {_increaseValue} to {quest.triggers::%{_p}'s uuid%::%{_questId}%}

local function questTriggerStatisticsOrderInit(p: player, questId: string):
    profileStatisticsSet({_p}, "_questTrigger_currentMoney", 0)

local function questTriggerStatisticsCompleteInit(p: player, questId: string):
    profileStatisticsClear({_p}, "_questTrigger_currentMoney")

local function getQuestIdFromItem(item: item) :: string:
    return string tag "TheMining;quest;id" of custom nbt of {_item}

local function isQuestDaily(questId: string) :: boolean:
    return true if getDefine("QUEST_TYPE::%{_questId}%") is 1
    return false

local function isQuestWeekly(questId: string) :: boolean:
    return true if getDefine("QUEST_TYPE::%{_questId}%") is 2
    return false

local function getQuestStatusFromId(p: player, questId: string) :: string:
    return "has" if {quest.has::%{_p}'s uuid%::*} contains {_questId}
    return "ordering" if {quest.ordering::%{_p}'s uuid%::*} contains {_questId}
    return "complete" if {quest.complete::%{_p}'s uuid%::*} contains {_questId}
    return "rewarded" if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}

local function isQuestOrderable(p: player, questId: string) :: boolean:
    return false if {quest.has::%{_p}'s uuid%::*} doesn't contain {_questId}
    return false if {quest.ordering::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.complete::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}
    return true

local function isQuestCompletable(p: player, questId: string) :: boolean:
    return false if {quest.has::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.ordering::%{_p}'s uuid%::*} doesn't contain {_questId}
    return false if {quest.complete::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}
    return true

local function isQuestRewardable(p: player, questId: string) :: boolean:
    return false if {quest.has::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.ordering::%{_p}'s uuid%::*} contains {_questId}
    return false if {quest.complete::%{_p}'s uuid%::*} doesn't contain {_questId}
    return false if {quest.rewarded::%{_p}'s uuid%::*} contains {_questId}
    return true

function isQuestInProgress(p: player, questId: string) :: boolean:
    return false if {quest.ordering::%{_p}'s uuid%::*} doesn't contain {_questId}
    return true

local function questOrder(p: player, questId: string) :: boolean:
    if isQuestOrderable({_p}, {_questId}) is true:
        remove {_questId} from {quest.has::%{_p}'s uuid%::*}
        add {_questId} to {quest.ordering::%{_p}'s uuid%::*}
        logInfo("QUEST_ORDERED", getQuestLogParameters({_p}'s uuid, {_questId}))
        questTriggerStatisticsOrderInit({_p}, {_questId})
        return true

    logError("ERR_QUEST_ORDER", getQuestLogParameters({_p}'s uuid, {_questId}))
    return false

local function questComplete(p: player, questId: string, isSkipCondition: boolean = false) :: boolean:
    set {_flag} to false
    set {_flag} to true if {_isSkipCondition} is true
    set {_flag} to true if isQuestCompletable({_p}, {_questId}) is true

    if {_flag} is true:
        remove {_questId} from {quest.ordering::%{_p}'s uuid%::*}
        add {_questId} to {quest.complete::%{_p}'s uuid%::*}
        logInfo("QUEST_COMPLETE", getQuestLogParameters({_p}'s uuid, {_questId}))
        return true
        
    logError("ERR_QUEST_COMPLETE", getQuestLogParameters({_p}'s uuid, {_questId}))
    return false

local function questRewards(p: player, questId: string) :: boolean:
    if isQuestRewardable({_p}, {_questId}) is true:
        remove {_questId} from {quest.complete::%{_p}'s uuid%::*}
        add {_questId} to {quest.rewarded::%{_p}'s uuid%::*}
        #å ±é…¬ã®ä»˜ä¸
        set {_exp} to getDefine("QUEST_REWARD::%{_questId}%::EXP")
        set {_money} to getDefine("QUEST_REWARD::%{_questId}%::MONEY")
        profileExpIncrease({_p}, {_exp}, "QUEST_REWARDS") if {_exp} is set
        profileMoneyIncrease({_p}, {_money}, "QUEST_REWARDS") if {_money} is set
        logInfo("QUEST_RECEIVE_REWARDS", getQuestLogParameters({_p}'s uuid, {_questId}))
        return true

    logError("ERR_QUEST_RECEIVE_REWARDS", getQuestLogParameters({_p}'s uuid, {_questId}))
    return false

#Interface
local function getQuestLogParameters(uuid: string, questId: string) :: objects:
    add {_uuid} to {_res::*}
    add {_questId} to {_res::*}
    return {_res::*}